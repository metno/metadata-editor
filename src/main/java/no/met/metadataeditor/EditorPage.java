package no.met.metadataeditor;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.logging.Logger;

import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlElement;

import no.met.metadataeditor.dataTypes.EditorVariable;
import no.met.metadataeditor.dataTypes.EditorVariableContent;
import no.met.metadataeditor.widget.EditorWidget;

public class EditorPage implements Serializable {

    private static final long serialVersionUID = 512799681077291836L;

    private String label;
    
    private String id;

    private List<EditorWidget> widgets = new ArrayList<>();
    
    public EditorPage() {

    }

    @XmlAttribute(required=true)
    public String getLabel() {
        return label;
    }

    public void setLabel(String label) {
        this.label = label;
    }

    @XmlAttribute(required=true)
    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    @XmlElement(name="widget", namespace="http://www.met.no/schema/metadataeditor/editorConfiguration")
    public List<EditorWidget> getWidgets() {
        return widgets;
    }

    public void setWidgets(List<EditorWidget> widgets) {
        this.widgets = widgets;
    }
    
    /**
     * Get the tree of widgets on the page as a list. The list is generated by traversing 
     * the widget tree depth first.
     * 
     * This is necessary since JSF2 does not support recursive components.
     * @return The list of editor widgets in the widget tree.
     */
    public List<EditorWidget> getWidgetTreeAsList(){
        
        List<EditorWidget> widgetTree = new ArrayList<>();        
        for( EditorWidget widget : widgets ) {
            
            widgetTree.add(widget);
            widgetTree.addAll(widget.getWidgetTreeAsList());
            
        }        
        
        return widgetTree;
    }
    
    private Map<String, EditorWidget> getWidgetMap(){
        
        Map<String,EditorWidget> widgetMap = new HashMap<>();
        for( EditorWidget widget : widgets ){
            widgetMap.put(widget.getVariableName(), widget);
        }
        return widgetMap;
        
    }
    
    public EditorWidget getWidget(String variableName){
        
        Map<String,EditorWidget> widgetMap = getWidgetMap();
        if(widgetMap.containsKey(variableName)){
            return widgetMap.get(variableName);
        }
        
        return null;
        
    }
    
    public boolean generateEditorWidgetViews(Map<String, List<EditorVariableContent>> contentMap){

        for( EditorWidget widget : widgets ){
            
            String varName = widget.getVariableName();
            if( !contentMap.containsKey(varName)){
                throw new InvalidEditorConfigurationException( varName + " has not associated content/variable in template.", InvalidEditorConfigurationException.UNKNOWN_VARIABLE );
            }
            
            List<EditorVariableContent> content = contentMap.get(varName);
            widget.generateWidgetViews(content);            
        }
                
        return allPopulated();
    }
    
    private boolean allPopulated(){
        
        Map<String,EditorWidget> widgetMap = getWidgetMap();
        List<String> notPopulated = new ArrayList<>();
        for(Map.Entry<String,EditorWidget> entry : widgetMap.entrySet() ){
            
            if(!entry.getValue().isPopulated()){
                Logger.getLogger(getClass().getName()).warning("EditorWidget '" + entry.getKey() + "' has not been populated" );
                notPopulated.add(entry.getKey());
            }
        }
        
        return notPopulated.isEmpty() ? true : false; 
    }
    
    public Map<String, List<EditorVariableContent>> getContent(){
        
        Map<String, List<EditorVariableContent>> content = new HashMap<>();
        for(EditorWidget widget : widgets){  
            content.put(widget.getVariableName(), widget.getContent());
        }
        return content;
    }

    public void validateVarNames(Map<String, EditorVariable> varMap) {

        for( EditorWidget widget : widgets ){
            if(! varMap.containsKey(widget.getVariableName())){
                throw new InvalidEditorConfigurationException("The variable '" + widget.getVariableName() + "' was not found in the template", InvalidEditorConfigurationException.UNKNOWN_VARIABLE);
            }
        }
        
    }

    /**
     * Add configuration from the editor variables to the editor widgets.
     * @param varMap The map of editor variables.
     * @throws InvalidEditorConfigurationException Thrown if a widget refersh to a variable not found
     * in the template. 
     * @return Always returns true at the moment.
     */
    public boolean configure(Map<String, EditorVariable> varMap) {
        
        for( EditorWidget widget : widgets ){
            
            String varName = widget.getVariableName();
            if( !varMap.containsKey(varName)){
                throw new InvalidEditorConfigurationException( varName + " is not found in the template.", InvalidEditorConfigurationException.UNKNOWN_VARIABLE );
            }
            
            EditorVariable ev = varMap.get(varName);
            widget.configure(ev);
        }
        
        return true;
    }

}
